generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

// model User {
//   id             String          @id @default(auto()) @map("_id") @db.ObjectId
//   name           String?
//   email          String?         @unique
//   hashedPassword String?
//   emailVerified  DateTime?
//   image          String?
//   role           String?         @default("user")
//   balance        Float?          @default(0.0)
//   phone          String?
//   accounts       Account[]
//   sessions       Session[]
//   customer Customer
//   authenticators Authenticator[] // Renamed for consistency
//   createdAt      DateTime        @default(now())
//   updatedAt      DateTime        @updatedAt
// }



model Customer {
  id                String            @id @default(auto()) @map("_id") @db.ObjectId
  email             String            @unique
  shippingAddresses ShippingAddress[]
  orders            Order[]
  userId            String            @unique @db.ObjectId // Unique userId for one-to-one relationship
  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// model Account {
//   id                String  @id @default(auto()) @map("_id") @db.ObjectId
//   userId            String  @db.ObjectId
//   type              String
//   provider          String
//   providerAccountId String
//   refreshToken      String? @db.String // Adjusted for case consistency
//   accessToken       String? @db.String
//   expiresAt         Int? // Adjusted for case consistency
//   tokenType         String? // Adjusted for case consistency
//   scope             String?
//   idToken           String? @db.String
//   sessionState      String?

//   createdAt DateTime @default(now())
//   updatedAt DateTime @updatedAt

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([provider, providerAccountId])
// }

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.String
  access_token      String? @db.String
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.String
  session_state     String?
 
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
 
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
 
  @@unique([provider, providerAccountId])
}
 

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model User {
  id                String            @id @default(auto()) @map("_id") @db.ObjectId
  name              String?
  email             String?           @unique
  hashedPassword    String?
  emailVerified     DateTime?
  image             String?
  role              String            @default("user") // Default role is "user"
  balance           Float             @default(0.0) // Default balance is 0.0
  phone             String?
  accounts          Account[] // A user can have multiple accounts
  sessions          Session[] // A user can have multiple sessions
  customer          Customer? // A user can have one customer profile
  orders            Order[]           @relation("UserOrders") // A user can have multiple orders
  shippingAddresses ShippingAddress[] @relation("UserShippingAddresses") // A user can have multiple shipping addresses
  authenticators    Authenticator[] // A user can have multiple authenticators
  createdAt         DateTime          @default(now()) // Automatically set on creation
  updatedAt         DateTime          @updatedAt // Automatically updated on change
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  credentialId         String  @id @map("_id") // Adjusted for case consistency
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialId])
}

model Category {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  categoryName String    @unique
  imageUrl     String
  link         String
  href         String?
  products     Product[]
}

model ShippingAddress {
  id             String    @id @default(auto()) @map("_id") @db.ObjectId
  name           String
  region         String
  city           String
  address        String
  phone          String
  country        String?
  email          String?
  deliveryMethod String?
  whatsappOptIn  Boolean?
  customerId     String?   @db.ObjectId
  customer       Customer? @relation(fields: [customerId], references: [id])
  orders         Order[] // Indicates a one-to-many relationship; can be empty
  // Add relationship to User
  userId         String?   @db.ObjectId
  user           User?     @relation(fields: [userId], references: [id], name: "UserShippingAddresses")
}

model Product {
  id            String           @id @default(auto()) @map("_id") @db.ObjectId
  title         String           @unique
  imageUrl      String
  images        Json?
  description   String
  discount      Int?
  price         Int?
  weight        Float?
  unit          String?
  categoryName  String
  category      Category?        @relation(fields: [categoryName], references: [categoryName])
  isInStock     String
  quantity      Int
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt
  productOrders ProductOrder[]
  purchaseCount Int              @default(0)
  variants      ProductVariant[] @relation("ProductVariants")
}

model ProductVariant {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  productId       String   @db.ObjectId
  product         Product  @relation("ProductVariants", fields: [productId], references: [id], onDelete: Cascade) // Define `onDelete` here
  weight          Float?
  price           Int?
  discountedPrice Int?
  unit            String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
}

model ProductOrder {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  productId     String   @db.ObjectId
  orderId       String   @db.ObjectId
  price         Int?
  weight        Int?
  unit          String?
  quantity      Int
  quantityTotal String?
  available     Boolean? @default(true)
  product       Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  order         Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model Order {
  id                       String           @id @default(auto()) @map("_id") @db.ObjectId
  referenceNumber          String
  orderNumber              String           @unique
  total                    Float?
  totalDue                 Float?
  creditAppliedTotal       Float?
  balanceApplied           Boolean?
  whatsappOptIn            Boolean?
  updatedOrderTotal        Float?
  userWhatsappOptIn        Json?
  balanceDeducted          Float?
  remainingAmount          Float?
  updatedBalance           Float?
  creditAppliedDeliveryFee Float?
  status                   String?          @default("processing")
  dispatchRiderId          String?          @db.ObjectId
  dispatchRider            DispatchRider?   @relation(fields: [dispatchRiderId], references: [id], onDelete: Cascade)
  shippingAddressId        String?          @db.ObjectId
  shippingAddress          ShippingAddress? @relation(fields: [shippingAddressId], references: [id])
  products                 ProductOrder[]
  deliveryMethod           String?
  deliveryFee              Int?
  customerId               String?          @db.ObjectId
  customer                 Customer?        @relation(fields: [customerId], references: [id])
  deliveryDate             String?
  cardType                 String?
  last4Digits              String?
  paymentMode              String?
  paymentAction            String?
  // Add relationship to User
  userId                   String?          @db.ObjectId
  user                     User?            @relation(fields: [userId], references: [id], name: "UserOrders")
  createdAt                DateTime         @default(now())
  updatedAt                DateTime         @updatedAt
}

model PickupLocations {
  id      String  @id @default(auto()) @map("_id") @db.ObjectId
  region  String?
  city    String?
  address String
}

model Management {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  email     String   @unique
  phone     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model CitiesWithFees {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  city        String
  deliveryFee Float
  region      String?
}

model PickupOptions {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  location String
}

model DispatchRider {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  gender    String?
  firstName String
  lastName  String
  phone     String?
  orders    Order[]
}
