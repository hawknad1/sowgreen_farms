generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model User {
  id             String          @id @default(auto()) @map("_id") @db.ObjectId
  name           String?
  email          String?         @unique
  hashedPassword String?
  emailVerified  DateTime?
  image          String?
  role           String?         @default("user")
  balance        Float?          @default(0.0)
  phone          String?         
  accounts       Account[]
  sessions       Session[]
  authenticators Authenticator[] // Renamed for consistency
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
}

model Account {
  id                String  @id @default(auto()) @map("_id") @db.ObjectId
  userId            String  @db.ObjectId
  type              String
  provider          String
  providerAccountId String
  refreshToken      String? @db.String // Adjusted for case consistency
  accessToken       String? @db.String
  expiresAt         Int? // Adjusted for case consistency
  tokenType         String? // Adjusted for case consistency
  scope             String?
  idToken           String? @db.String
  sessionState      String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(auto()) @map("_id") @db.ObjectId
  sessionToken String   @unique
  userId       String   @db.ObjectId
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model VerificationToken {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  identifier String
  token      String
  expires    DateTime

  @@unique([identifier, token])
}

model Authenticator {
  credentialId         String  @id @map("_id") // Adjusted for case consistency
  userId               String  @db.ObjectId
  providerAccountId    String
  credentialPublicKey  String
  counter              Int
  credentialDeviceType String
  credentialBackedUp   Boolean
  transports           String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, credentialId])
}

model Category {
  id           String    @id @default(auto()) @map("_id") @db.ObjectId
  categoryName String    @unique
  imageUrl     String
  link         String
  href         String?
  products     Product[]
}

model ShippingAddress {
  id      String  @id @default(auto()) @map("_id") @db.ObjectId
  name    String
  region  String
  city    String
  address String
  phone   String
  country String?
  email   String?
  orders  Order[] // Indicates a one-to-many relationship; can be empty
}

model Product {
  id            String         @id @default(auto()) @map("_id") @db.ObjectId
  title         String         @unique
  imageUrl      String
  images        Json?
  description   String
  discount      Int?
  price         Int?
  weight        Float?
  unit          String?
  categoryName  String
  category      Category?      @relation(fields: [categoryName], references: [categoryName])
  isInStock     String
  quantity      Int
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  productOrders ProductOrder[]
  purchaseCount Int            @default(0)

  // weightsAndPrices WeightPrice[]
}

// model DeliveryMethod {
//   id              String         @id @default(auto()) @map("_id") @db.ObjectId
//   label           String
//   tag             String?
//   price           String?
//   value           String
//   pickupOptions   PickupOption[] @relation("DeliveryMethodPickupOptions") // Establishing relation with PickupOption
// }

// model PickupOption {
//   id               String         @id @default(auto()) @map("_id") @db.ObjectId
//   label            String
//   deliveryMethodId String         @db.ObjectId
//   deliveryMethod   DeliveryMethod @relation("DeliveryMethodPickupOptions", fields: [deliveryMethodId], references: [id]) // Linking back to DeliveryMethod
// }

model PickupOptions {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  location String
}

// model DeliveryMethod {
//   id                String           @id @default(auto()) @map("_id") @db.ObjectId
//   label String
//   tag String
//   value String

// }

// model WeightPrice {
//   id        String  @id @default(auto()) @map("_id") @db.ObjectId // MongoDB requires an @id field
//   weight    Float?
//   price     Int?
//   product   Product @relation(fields: [productId], references: [id]) // Opposite relation field
//   productId String  @db.ObjectId
// }

model Order {
  id                String           @id @default(auto()) @map("_id") @db.ObjectId
  referenceNumber   String
  orderNumber       String           @unique
  total             Float?
  status            String?          @default("processing")
  dispatchRider     String?
  shippingAddressId String?          @db.ObjectId
  shippingAddress   ShippingAddress? @relation(fields: [shippingAddressId], references: [id])
  products          ProductOrder[]
  deliveryMethod    String
  deliveryFee       Int?
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt
}

model ProductOrder {
  id            String  @id @default(auto()) @map("_id") @db.ObjectId
  productId     String  @db.ObjectId
  orderId       String  @db.ObjectId
  quantity      Int
  quantityTotal String
  product       Product @relation(fields: [productId], references: [id])
  order         Order   @relation(fields: [orderId], references: [id])
}

model Management {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  name      String
  email     String   @unique
  phone     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}
